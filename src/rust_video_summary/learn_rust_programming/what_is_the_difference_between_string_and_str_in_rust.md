# What is the difference between string and &str in rust

<!--ts-->
* [What is the difference between string and &amp;str in rust](#what-is-the-difference-between-string-and-str-in-rust)
   * [Difference between String and &amp;str](#difference-between-string-and-str)
      * [String vs. &amp;str](#string-vs-str)
   * [Strings and Strs Always Look Different](#strings-and-strs-always-look-different)
      * [Representation of Strings in Source Code](#representation-of-strings-in-source-code)
   * [Why Is Ampersand Necessary?](#why-is-ampersand-necessary)
      * [The Role of Ampersand](#the-role-of-ampersand)
      * [Fixed Size Limitations](#fixed-size-limitations)
      * [String Capacity](#string-capacity)
      * [Borrowing](#borrowing)
   * [Understanding Rust Strings and String Slices](#understanding-rust-strings-and-string-slices)
      * [Creating a Function with Strings](#creating-a-function-with-strings)
      * [Borrowing Variables](#borrowing-variables)
      * [Differences Between Strings and String Slices](#differences-between-strings-and-string-slices)
      * [Conclusion](#conclusion)
   * [Generated by Video Highlight](#generated-by-video-highlight)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: runner, at: Wed Apr 19 08:50:58 UTC 2023 -->

<!--te-->

## Difference between String and &str

Section Overview: In this section, the speaker explains the difference between String and &str in Rust programming.

### String vs. &str

- A String is more versatile than a string slice (&str).
- A string slice has fewer methods.
- A string slice doesn't allow any extra information to be appended at the end.
- If we try to compile a program with a string slice, we'll receive an error message from the compiler saying that
  push_str or reference &str won't work.
- On the other hand, a String will compile and run without any issues.

## Strings and Strs Always Look Different

Section Overview: In this section, the speaker talks about how Strings and strs always look different in Rust
programming.

### Representation of Strings in Source Code

- Whenever you see a string literal in Rust, it is never an actual string.
- It is a "string slice" which has "&str" as its type.
- If we tell Rust that it's a string, we'll get an error message from the compiler saying that it expected a string but
  found an &str instead.
- To convert an &str to a String, we can use the "to_string()" method.

## Why Is Ampersand Necessary?

Section Overview: In this section, the speaker explains why ampersand is necessary when dealing with strings and slices
in Rust programming.

### The Role of Ampersand

- The ampersand precedes the type (string slice) because it indicates that we are borrowing data rather than owning it.
- When we borrow data using &, we don't have to worry about deallocating memory since ownership remains with the
  original owner of data.
- Without &, Rust would not know how much memory to allocate for str since its size cannot be known at compilation time.
- Therefore, the ampersand is necessary to indicate that we are borrowing data and not owning it.

## [#](t=0:04:57s) Understanding Rust Strings

Section Overview: In this section, the speaker explains how Rust handles strings and string slices. They discuss the
conflict beginners face when trying to understand why the Rust compiler behaves in a certain way and explain how
references are used to get around fixed size limitations.

### Fixed Size Limitations

- [](t=0:05:01s) Beginners often struggle with understanding why the Rust compiler behaves in a certain way.
- [](t=0:05:23s) Every function call needs to be of a fixed size, which makes it difficult to fit things of arbitrary
  length inside something that requires a fixed length.
- [](t=0:06:02s) References are used to get around fixed size limitations by adding a reference to the text, which has a
  fixed size represented internally as a number.

### String Capacity

- [](t=0:07:32s) Strings have more than just an internal pointer and length of bytes; they also have capacity.
- [](t=0:08:18s) The capacity of strings can change, allowing for reserving extra space.

### Borrowing

- [](t=0:09:03s) Borrowing is one of the most fundamental distinctions between strings and string slices.
- [](t=0:09:14s) A string is called an "owned value," whereas a string slice is called a "borrowed value."
- [](t=0:09:52s) When welcome leaves scope, it will delete any data that it owns. However, borrowed values do not own
  data and will not delete anything.

## Understanding Rust Strings and String Slices

Section Overview: In this video, the speaker explains the differences between Rust strings and string slices. He
demonstrates how to create a function that prints a message using both types of variables and highlights the limitations
of using strings.

### Creating a Function with Strings

- The speaker creates a function called `print_message` that takes in a message as an argument.
- When trying to pass in a string variable called `welcome`, which is defined outside of the function, the compiler
  throws an error because it is not mutable.
- If we change the definition of `welcome` to be a string instead of a variable, it will fail to compile because
  once `welcome` leaves scope, it no longer exists.

### Borrowing Variables

- To get around this limitation, we can borrow the `welcome` variable again within the `print_message` function.
- After fixing some type definition issues, borrowing works fine.

### Differences Between Strings and String Slices

- The fundamental difference between strings and string slices is that strings are owned values while string slices are
  borrowed values.

### Conclusion

- The speaker invites viewers to subscribe to his channel for more content on Rust programming. He also encourages
  viewers to ask for explanations on specific topics they would like to learn.

## Generated by Video Highlight

https://videohighlight.com/video/summary/n7-vKRLw3zg